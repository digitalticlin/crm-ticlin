
import { useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Contact } from "@/types/chat";
import { KanbanLead } from "@/types/kanban";

interface UseRealtimeLeadsProps {
  selectedContact: Contact | null;
  fetchContacts: () => Promise<void>;
  fetchMessages: () => Promise<void>; // fetchMessages can be undefined
  receiveNewLead: (leadData: Omit<KanbanLead, "id" | "name" | "columnId">) => void;
}

export function useRealtimeLeads({
  selectedContact,
  fetchContacts,
  fetchMessages,
  receiveNewLead,
}: UseRealtimeLeadsProps) {
  useEffect(() => {
    // Ensure stable references for dependencies if they come from other hooks.
    // If fetchContacts, fetchMessages, receiveNewLead are not stable (e.g. not useCallback'd),
    // this effect might re-run excessively.

    const leadsChannel = supabase
      .channel('public:leads:chat_subscription') // Unique channel name
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'leads',
        },
        async (payload) => {
          console.log('Novo lead recebido (realtime):', payload);
          const newLeadData = payload.new as {
            id: string;
            name: string; // Name might be generated by the webhook, keep for consistency if payload includes it
            phone: string;
            last_message: string | null;
            last_message_time: string | null;
          };

          if (newLeadData && newLeadData.phone) {
            try {
              receiveNewLead({
                phone: newLeadData.phone,
                lastMessage: newLeadData.last_message || "",
                lastMessageTime: newLeadData.last_message_time
                  ? new Date(newLeadData.last_message_time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                  : "Agora",
                tags: [],
              });
              await fetchContacts();
            } catch (error) {
              console.error("Erro ao processar novo lead (realtime):", error);
            }
          }
        }
      )
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'leads',
        },
        async (payload) => {
          console.log('Lead atualizado (realtime):', payload);
          // If the currently selected contact is updated
          if (selectedContact && payload.new.id === selectedContact.id) {
            const newLastMessage = (payload.new as { last_message?: string }).last_message;
            const oldLastMessage = (payload.old as { last_message?: string }).last_message;
            if (newLastMessage !== oldLastMessage && fetchMessages) {
              await fetchMessages();
            }
          }
          // Always refresh the contact list on any lead update visible to the user
          await fetchContacts();
        }
      )
      .subscribe((status, err) => {
        if (status === 'SUBSCRIBED') {
          console.log('Subscribed to leads changes for chat.');
        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || err) {
          console.error('Realtime leads subscription error:', status, err);
        }
      });

    return () => {
      supabase.removeChannel(leadsChannel);
    };
  }, [fetchContacts, fetchMessages, selectedContact, receiveNewLead]);
}
