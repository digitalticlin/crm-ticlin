
import { supabase } from "@/integrations/supabase/client";

interface DiagnosticResult {
  test: string;
  success: boolean;
  duration: number;
  details: any;
  timestamp: string;
  recommendations?: string[];
}

export interface ComprehensiveDiagnostic {
  overallStatus: 'healthy' | 'warning' | 'critical';
  totalTests: number;
  successCount: number;
  failureCount: number;
  totalDuration: number;
  results: DiagnosticResult[];
  analysis: {
    connectivity: 'ok' | 'degraded' | 'failed';
    authentication: 'ok' | 'failed';
    services: 'ok' | 'partial' | 'failed';
    flow: 'ok' | 'failed';
    version: 'ok' | 'outdated' | 'unknown';
  };
  recommendations: string[];
  timestamp: string;
}

export class VPSDiagnosticService {
  
  static async runComprehensiveDiagnostic(): Promise<ComprehensiveDiagnostic> {
    console.log('[VPS Diagnostic Service] üöÄ Iniciando diagn√≥stico completo FASE 2');
    
    const startTime = Date.now();
    const results: DiagnosticResult[] = [];
    
    const tests = [
      { name: 'vps_connectivity', label: 'Conectividade VPS' },
      { name: 'vps_auth', label: 'Autentica√ß√£o VPS' },
      { name: 'vps_services', label: 'Servi√ßos VPS' },
      { name: 'full_flow', label: 'Fluxo Completo (check_server)' }
    ];

    // Executar cada teste
    for (const test of tests) {
      console.log(`[VPS Diagnostic Service] üß™ Executando: ${test.label}`);
      
      try {
        const { data, error } = await supabase.functions.invoke('vps_diagnostic', {
          body: { 
            test: test.name,
            vpsAction: test.name === 'full_flow' ? 'check_server' : undefined
          }
        });

        if (error) {
          throw error;
        }

        const result: DiagnosticResult = {
          test: test.label,
          success: data.success || false,
          duration: data.duration || 0,
          details: data.details || {},
          timestamp: data.timestamp || new Date().toISOString(),
          recommendations: data.recommendations || []
        };

        results.push(result);
        console.log(`[VPS Diagnostic Service] ${result.success ? '‚úÖ' : '‚ùå'} ${test.label}: ${result.success ? 'OK' : 'FALHA'}`);

      } catch (error: any) {
        console.error(`[VPS Diagnostic Service] ‚ùå Erro no teste ${test.name}:`, error);
        
        const errorResult: DiagnosticResult = {
          test: test.label,
          success: false,
          duration: 0,
          details: { error: error.message },
          timestamp: new Date().toISOString(),
          recommendations: [`Resolver erro: ${error.message}`]
        };
        
        results.push(errorResult);
      }
    }

    // An√°lise dos resultados CORRIGIDA
    const analysis = this.analyzeResults(results);
    const overallStatus = this.determineOverallStatus(analysis);
    const recommendations = this.generateRecommendations(results, analysis);
    
    const diagnostic: ComprehensiveDiagnostic = {
      overallStatus,
      totalTests: results.length,
      successCount: results.filter(r => r.success).length,
      failureCount: results.filter(r => !r.success).length,
      totalDuration: Date.now() - startTime,
      results,
      analysis,
      recommendations,
      timestamp: new Date().toISOString()
    };

    console.log('[VPS Diagnostic Service] üìä Diagn√≥stico FASE 2 conclu√≠do:', {
      status: diagnostic.overallStatus,
      sucessos: diagnostic.successCount,
      falhas: diagnostic.failureCount,
      duracao: `${diagnostic.totalDuration}ms`
    });

    return diagnostic;
  }

  private static analyzeResults(results: DiagnosticResult[]) {
    const connectivity = results.find(r => r.test === 'Conectividade VPS');
    const authentication = results.find(r => r.test === 'Autentica√ß√£o VPS');
    const services = results.find(r => r.test === 'Servi√ßos VPS');
    const flow = results.find(r => r.test === 'Fluxo Completo (check_server)');

    // CORRE√á√ÉO: An√°lise de vers√£o melhorada para aceitar 3.5.0
    let versionStatus: 'ok' | 'outdated' | 'unknown' = 'unknown';
    
    // Verificar vers√£o nos detalhes de conectividade
    if (connectivity?.success && connectivity.details?.version) {
      const version = connectivity.details.version;
      if (this.isValidVersion(version)) {
        versionStatus = 'ok';
        console.log('[VPS Diagnostic Service] ‚úÖ Vers√£o v√°lida detectada:', version);
      } else {
        versionStatus = 'outdated';
        console.log('[VPS Diagnostic Service] ‚ö†Ô∏è Vers√£o n√£o reconhecida:', version);
      }
    }

    return {
      connectivity: connectivity?.success ? 'ok' : 'failed' as 'ok' | 'degraded' | 'failed',
      authentication: authentication?.success ? 'ok' : 'failed' as 'ok' | 'failed',
      services: services?.success ? 'ok' : 'failed' as 'ok' | 'partial' | 'failed',
      flow: flow?.success ? 'ok' : 'failed' as 'ok' | 'failed',
      version: versionStatus
    };
  }

  // CORRE√á√ÉO: Fun√ß√£o de valida√ß√£o de vers√£o atualizada para aceitar 3.5.0
  private static isValidVersion(versionString: string): boolean => {
    if (!versionString) return false;
    
    // Lista de vers√µes v√°lidas atualizada
    const validVersions = [
      '3.5.0', // CORRE√á√ÉO: Vers√£o atual da VPS - V√ÅLIDA
      '3.4.0',
      '3.3.0',
      '3.2.0',
      '3.1.0',
      '3.0.0'
    ];
    
    // Verificar se √© uma vers√£o exata conhecida
    if (validVersions.includes(versionString)) {
      return true;
    }

    // Verificar padr√£o semver e aceitar todas as vers√µes 3.x
    const semverPattern = /^(\d+)\.(\d+)\.(\d+)$/;
    const match = versionString.match(semverPattern);
    
    if (!match) return false;
    
    const [, major] = match;
    const majorNum = parseInt(major);
    
    // CORRE√á√ÉO: Aceitar todas as vers√µes 3.x como v√°lidas
    return majorNum >= 3;
  }

  private static determineOverallStatus(analysis: any): 'healthy' | 'warning' | 'critical' {
    const failedComponents = Object.values(analysis).filter(status => status === 'failed').length;
    const outdatedComponents = Object.values(analysis).filter(status => status === 'outdated').length;
    
    if (failedComponents === 0 && outdatedComponents === 0) return 'healthy';
    if (failedComponents <= 1 || outdatedComponents > 0) return 'warning';
    return 'critical';
  }

  private static generateRecommendations(results: DiagnosticResult[], analysis: any): string[] {
    const recommendations: string[] = [];

    if (analysis.connectivity === 'failed') {
      recommendations.push('üîß Verificar conectividade de rede com a VPS (31.97.24.222:3001)');
      recommendations.push('üîß Confirmar se a VPS est√° online e acess√≠vel');
    }

    if (analysis.authentication === 'failed') {
      recommendations.push('üîê TOKEN CORRIGIDO: Verificar se VPS_API_TOKEN est√° configurado corretamente');
      recommendations.push('üîê Token correto deve ser: 3oOb0an43kLEO6cy3bP8LteKCTxshH8eytEV9QR314dcf0b3');
    }

    if (analysis.services === 'failed') {
      recommendations.push('‚öôÔ∏è Verificar se o servidor WhatsApp Web.js est√° rodando na VPS');
      recommendations.push('‚öôÔ∏è Reiniciar servi√ßos WhatsApp na VPS se necess√°rio');
    }

    if (analysis.flow === 'failed') {
      recommendations.push('üîÑ Verificar integra√ß√£o completa entre Supabase Edge Functions e VPS');
      recommendations.push('üîÑ Testar cria√ß√£o manual de inst√¢ncia para identificar ponto de falha');
    }

    // CORRE√á√ÉO: Mensagem de vers√£o atualizada para 3.5.0
    if (analysis.version === 'ok') {
      recommendations.push('‚úÖ Vers√£o do WhatsApp Web.js est√° atualizada (3.5.0) - FASE 2 OK');
    } else if (analysis.version === 'unknown') {
      recommendations.push('‚ùì N√£o foi poss√≠vel determinar a vers√£o do WhatsApp Web.js');
    }

    // Recomenda√ß√µes espec√≠ficas baseadas nos detalhes
    results.forEach(result => {
      if (result.recommendations) {
        recommendations.push(...result.recommendations);
      }
    });

    return [...new Set(recommendations)]; // Remove duplicatas
  }

  static formatDiagnosticReport(diagnostic: ComprehensiveDiagnostic): string {
    const statusEmoji = {
      'healthy': 'üü¢',
      'warning': 'üü°', 
      'critical': 'üî¥'
    };

    const analysisEmoji = {
      'ok': '‚úÖ',
      'degraded': '‚ö†Ô∏è',
      'partial': '‚ö†Ô∏è',
      'failed': '‚ùå',
      'outdated': 'üì¶',
      'unknown': '‚ùì'
    };

    let report = `
# üìã DIAGN√ìSTICO VPS - FASE 2 IMPLEMENTADA

## ${statusEmoji[diagnostic.overallStatus]} STATUS GERAL: ${diagnostic.overallStatus.toUpperCase()}

**Resumo dos Testes:**
- ‚úÖ Sucessos: ${diagnostic.successCount}/${diagnostic.totalTests}
- ‚ùå Falhas: ${diagnostic.failureCount}/${diagnostic.totalTests} 
- ‚è±Ô∏è Dura√ß√£o total: ${diagnostic.totalDuration}ms
- üìÖ Executado em: ${new Date(diagnostic.timestamp).toLocaleString()}

## üîç AN√ÅLISE POR COMPONENTE

| Componente | Status | Resultado |
|------------|---------|-----------|
| üåê Conectividade VPS | ${analysisEmoji[diagnostic.analysis.connectivity]} | ${diagnostic.analysis.connectivity.toUpperCase()} |
| üîê Autentica√ß√£o VPS | ${analysisEmoji[diagnostic.analysis.authentication]} | ${diagnostic.analysis.authentication.toUpperCase()} |
| ‚öôÔ∏è Servi√ßos VPS | ${analysisEmoji[diagnostic.analysis.services]} | ${diagnostic.analysis.services.toUpperCase()} |
| üîÑ Fluxo Completo | ${analysisEmoji[diagnostic.analysis.flow]} | ${diagnostic.analysis.flow.toUpperCase()} |
| üì¶ Vers√£o WhatsApp | ${analysisEmoji[diagnostic.analysis.version]} | ${diagnostic.analysis.version.toUpperCase()} |

## üìä DETALHES DOS TESTES
`;

    diagnostic.results.forEach((result, index) => {
      const emoji = result.success ? '‚úÖ' : '‚ùå';
      report += `
### ${index + 1}. ${emoji} ${result.test}
- **Status:** ${result.success ? 'SUCESSO' : 'FALHA'}
- **Dura√ß√£o:** ${result.duration}ms
- **Timestamp:** ${new Date(result.timestamp).toLocaleString()}
`;

      if (!result.success && result.details.error) {
        report += `- **Erro:** ${result.details.error}\n`;
      }
    });

    if (diagnostic.recommendations.length > 0) {
      report += `
## üîß RECOMENDA√á√ïES

${diagnostic.recommendations.map(rec => `- ${rec}`).join('\n')}
`;
    }

    return report;
  }
}
